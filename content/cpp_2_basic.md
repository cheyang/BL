1. `new/delete, malloc/free, new[]/delete[]`
* (1)malloc/free是函数，new/delete是c++运算符。
* (2)new会调用对象的构造函数；delete会调用对象的析构函数；malloc/free只会分配/释放内存。
* (3)delete[]会先依次调用每个元素的析构函数，然后调用operator delete来释放数组的内存。在使用时，一定要new/delete, new[]/delete[]配对使用。
* (4)对于内建对象，delete[]可以用来替代delete ('但不推荐这样用')


2. `引用`
* (1)c++中的引用，不分配内存。使用引用对象和直接操作被引用对象，具有相同的效果。
* (2)引用在声明时就需要对其初始化。
* (3)将引用作为函数参数/返回值:
	* 能够减少对象的构造和析构次数，与传指针效果相同。若直接传对象，会调用拷贝构造函数。
	* 当不想在函数中改变值时，使用const引用.
	* 不能返回局部变量的引用，因为在函数执行完毕后，该变量将被销毁。


3. `临时对象`
```cpp
string foo();
void bar(string & s);
// 下面的表达式是非法的
bar(foo());
bar("hello world");
```
* foo()函数返回一个临时对象，C++中临时对象是`const`类型的;在返回临时对象的时候，会调用该对象的构造函数和析构函数.
* "hello world"常量也是const类型的.


4. `复杂的函数声明`
```cpp
float (* (*p1)(int*))(int*);
// p1是一个函数指针，参数为int*类型。返回值是一个指针，指向一个函数，函数的参数为int*，返回值为float.

void* (* (*p2)(int) )[10];
// p2是一个函数指针，参数是int类型。返回值是一个指针，指向一个数组，该数组大小为10，元素为void*.

int (* (*p3)())[10]();
// p3是一个函数指针，参数为void。返回值是一个指针，
// 该指针指向一个数组，数组大小为10，数组中存放的是函数指针，类型为int(*p)()。
```

