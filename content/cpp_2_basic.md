1 `new/delete, malloc/free, new[]/delete[]`
* (1)malloc/free是函数，new/delete是c++运算符。
* (2)new会调用对象的构造函数；delete会调用对象的析构函数；malloc/free只会分配/释放内存。
* (3)delete[]会先依次调用每个元素的析构函数，然后调用operator delete来释放数组的内存。在使用时，一定要new/delete, new[]/delete[]配对使用。
* (4)对于内建对象，delete[]可以用来替代delete ('但不推荐这样用')


2 `引用`
* (1)c++中的引用，不分配内存。使用引用对象和直接操作被引用对象，具有相同的效果。
* (2)引用在声明时就需要对其初始化。
* (3)将引用作为函数参数/返回值:
	* 能够减少对象的构造和析构次数，与传指针效果相同。若直接传对象，会调用拷贝构造函数。
	* 当不想在函数中改变值时，使用const引用.
	* 不能返回局部变量的引用，因为在函数执行完毕后，该变量将被销毁。


3 `临时对象`
```cpp
string foo();
void bar(string & s);
// 下面的表达式是非法的
bar(foo());
bar("hello world");
```
* foo()函数返回一个临时对象，C++中临时对象是`const`类型的;在返回临时对象的时候，会调用该对象的构造函数和析构函数.
* "hello world"常量也是const类型的.


4 `复杂的函数声明`
```cpp
float (* (*p1)(int*))(int*);
// p1是一个函数指针，参数为int*类型。返回值是一个指针，指向一个函数，函数的参数为int*，返回值为float.

void* (* (*p2)(int) )[10];
// p2是一个函数指针，参数是int类型。返回值是一个指针，指向一个数组，该数组大小为10，元素为void*.

int (* (*p3)())[10]();
// p3是一个函数指针，参数为void。返回值是一个指针，
// 该指针指向一个数组，数组大小为10，数组中存放的是函数指针，类型为int(*p)()。
```

5 `进程与线程的区别`
* (1)进程是资源分配的最小单位，线程是CPU调度的最小单位。
* (2)线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
* (3)线程ID不同
* (4)线程栈不同：每个线程拥有自己的线程栈，是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。
* (5)errno不同
* (6)线程的优先级: 由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。
* (7)线程的信号屏蔽字: 每个线程所感兴趣的信号不同，所以线程的信号屏蔽字应该由线程自己管理。但所有的线程都共享同样的信号处理函数。
* (8)**寄存器组的值**: 当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

6 `进程间通信`
各有什么优缺点、使用时需要注意一些什么问题。
* (1)用于消息传递：管道pipe，命名管道fifo，消息队列msgqueue
* (2)用于同步（锁）：互斥锁mutex, 读写锁rdlock, 文件锁flock, 条件变量pthread_cond_t, 信号量semphore
* (3)用于通知：signal
* (4)用于共享的：共享内存
* (5)socket
