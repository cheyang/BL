## 系统设计与性能优化之一：总论
 
### 1 系统层次结构

![sdaa_1_1](https://github.com/justscu/BL/blob/master/pics/sdaa_1_1.png)

服务端的系统，简单的可分为三个层次：应用层、服务层和数据层。一般不允许跨层调用，也不允许下层调用上层，各层通过socket进行调用。
- **应用层**，用来作为系统的接入层，接收用户的接入请求。如Nginx，HAProxy等。应用层一般处理具体的业务逻辑，要求是无状态的、提供负载均衡和高可用性。常常会加入缓存来加快用户的访问速度并减小后端服务器的压力。
- **服务层**(app层)，用来提供可靠的、稳定的服务。应用层将客户端的请求处理完毕后，交给服务层，由服务层来查询数据库，计算等操作，并将结果返回给应用层。
- **数据层**，一般是数据库系统、存储系统，作为数据的提供者和保存者。
    
### 2 系统考量面
在设计系统时，需要考量以下几个方面问题：
- **性能**：QPS、并发量、System Load、网络IO、磁盘IO；
- **可用性**：当系统中某台服务器挂掉了，用户的请求能够透明的被切换到另外一台服务器上；
- **伸缩性**：能够很方便的往系统中增加/减少服务器的数量；
- **扩展性**：能够很容易的扩展服务器的功能；
- **安全性**：系统的抗攻击能力、SQL注入、DDos、SYN flood等。

### 3 系统性能

![sdaa_1_2](https://github.com/justscu/BL/blob/master/pics/sdaa_1_2.png)

- 系统的**并发量**，指系统能够同时处理的请求的数目。
- 系统的**吞吐量**，指单位时间内，系统处理的请求的数目。如每秒处理事务数（TPS），每秒查询数（QPS）等。 
![sdaa_1_3](https://github.com/justscu/BL/blob/master/pics/sdaa_1_3.png)

![sdaa_1_4](https://github.com/justscu/BL/blob/master/pics/sdaa_1_4.png)

### 4 系统可用性
实现系统的**高可用性**，主要从数据和服务的冗余备份及失效转移方面考虑。若某服务器宕机，可以立即将请求转移到其他服务器上去。或者数据磁盘被损坏，能够立即从备份磁盘中读取。

（1）应用层通常将多个服务器组成集群统一对外提供服务，在服务的入口处（如LVS）加入对应用服务器的健康检查，当服务器不可用时，将该服务器从可以列表中删除；待该服务器可用时，再将其加入到可用服务器列表中。

（2）应用层服务器集群对Session的管理
- Session复制：多台服务器集群间通过复制Session的方式共享。不适合Session较多的情况。
- Session绑定：利用Hash源地址的方式，每次将同一IP地址的请求，发送到同一服务器。当该服务器宕机时，会丢失Session。
- 利用Cookie记录Session：将Session记录在客户端，每次请求时，客户端将Session发给服务器，服务器处理完毕后，再将新的Session发给客户端。受制于客户端Cookie的限制。
- Session服务器：独立部署Session服务器集群，应用服务器每次读写Session时，去访问Session服务器。

（3）服务层也是通过集群方式实现高可用性。一般会有一个分布式的**服务调用框架**，该框架由服务注册、服务发现、负载均衡等部分组成。请求通过服务调用框架发到最合适的服务器上。
- 重要的服务，单独部署；并部署在更好的硬件上；
- 设置服务超时机制；
- 将请求进行分解，并异步调用；快速将数据返回给客户端，然后再写数据库等操作；
- 在高峰情况下，关闭不重要的服务，保障重要服务；

（4）位于数据层的服务器有所不同。数据访问不可中断、服务器宕机时保证数据不丢失。需要对数据进行冗余备份（在写的时候，写多台服务器），当数据库挂掉时，能够立即切换到备份数据库上去。
- 保证数据有多个副本；
- 数据持久化；
- 失效转移，当副本失效时，能够快速将访问转移到其它副本上；
- CAP原理：数据的可用性、一致性、分区耐受性不可能同时满足；一般牺牲数据的一致性；
- 数据强一致（各副本数据一致）、数据用户一致（各副本数据可能不一致，但用户访问时，通过纠错和校验机制，最终返回给用户的数据一致）、数据最终一致（各数据副本不一致、用户访问到的数据也可能不一致、但系统经过一段时间的自我恢复和修正后，数据最终一致）；

（5）数据备份包括冷备份（直接写磁盘光盘）、同步热备（同时写）、异步热备（主写从读）。 

### 5 系统伸缩性
系统**伸缩性**是指不需要改变系统的软硬件设计，仅仅通过改变服务器部署的数量，就可增加/减小系统的处理能力。
一般通过服务器集群来解决系统伸缩性问题；也可以将服务器的部分功能单独拿出来部署（如缓存单独部署、数据库单独部署、静态数据单独部署等），以提高系统的处理能力。

（1）应用层服务器是无状态的，可以通过集群的方式进行部署，以提高系统的伸缩性【负载均衡】。

（2）缓存系统，可以设计成分布式缓存集群，以提高系统的伸缩性。
- 分布式缓存中各台服务器中的缓存数据可能不同，读写数据时，必须要知道对哪台服务器进行操作。
- 往分布式缓存集群中加入机器后，原来缓存在其它服务器中的数据，应该尽量的被访问到。
- 分布式缓存采用一致性hash算法，来尽可能的减少新加入的机器对原有缓存数据的影响。

（3）存储系统，可以设计成服务器集群，以提高系统的伸缩性。缓存的数据可以丢失，但存储系统的数据是不能够丢失的，而且还必须保证数据的正确性和可用性。

![sdaa_1_5](https://github.com/justscu/BL/blob/master/pics/sdaa_1_5.png)

对于分布式存储系统，需要考虑以下几个方面的问题（可用性、伸缩性、效率）： 
- 主从备份，当主挂掉后，从能够立即升级为主；
- 当往集群中加入/删除一组机器时，涉及到数据的迁移【一致性hash算法】；
- 读写分离，加快数据库的读写操作；
- 对于内存数据库，还应当注意数据恢复（需要额外的数据持久化，以便从持久化的数据中恢复）

### 6 系统扩展性
系统的扩展性是指，在不改变服务器现有代码和部署的情况下，可以很方便的增加一些新的功能。

（1）利用分布式消息队列（ActiveMQ），增强系统扩展性 

![sdaa_1_6](https://github.com/justscu/BL/blob/master/pics/sdaa_1_6.png)

利用ActiveMQ队列服务器，可以将生产者和消费者进行解耦。生产者发布消息，消费者订阅自己感兴趣的消息。这样很容易对生产者和消费者的数量进行扩展，也可以很容易对现有功能进行扩展（比如新加一个所有股票的最近5分钟交易量排行）。
当业务量较大时，就对ActiveMQ的性能和稳定性提出了较高要求：
- 当生产者的消息较多，消费者来不及消费。MQ内存满时，会写磁盘。
- ActiveMQ宕机。为了保证MQ宕机后消息不丢失，生产者会将消息先保存起来，待消费者消费成功后，生产者才将消息删除。
- 多个消费者订阅相同的内容，但消费者消费的速度不同步。

（2）利用服务注册/服务发现框架，增强系统扩展性

![sdaa_1_7](https://github.com/justscu/BL/blob/master/pics/sdaa_1_7.png)

- app程序启动后，自行到Zookeeper下注册临时节点。服务发现服务关注ZK临时节点变化，从临时节点中提取关于app的信息，并对app进行健康检查。
- 通过健康检查的app，放入到可用服务列表中；当app通不过健康检查时，从可用服务器列表中将app删除。
- 利用该框架，可以很容易扩展app的数量和功能。 